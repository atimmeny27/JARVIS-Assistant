<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Centered Triangle Cutout</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
    
    body {
      margin: 0;
      background: #000000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .wrapper {
      position: relative;
      width: 0;
      height: 0;
    }

    .green-line {
      position: absolute;
      width: 63px;
      height: 15px;
      background-color: rgb(0, 0, 0);
      z-index: 3;
    }

    .triangle {
      width: 0;
      height: 0;
      border-left: 160px solid transparent;
      border-right: 160px solid transparent;
      border-top: 280px solid #9df;
      position: absolute;
      transform: translate(-50%, -45%);
      z-index: 1;
    }

    .triangle-smaller {
      width: 0;
      height: 0;
      border-left: 125px solid transparent;
      border-right: 125px solid transparent;
      border-top: 220px solid #000;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -47%);
      z-index: 2;
    }

    .world-map {
      position: absolute;
      top: -440px;
      left: 520px;
      width: 300px;
      height: 300px;
      opacity: 0.8;
      z-index: 1;
      pointer-events: none;
      filter: drop-shadow(0 0 10px #9df)
    }

    .box{
        width: 270px;
        height: 180px;
        position: absolute;
        top: -400px;
        left: 525px;
        background-color: transparent;  
        border: 2px solid #9df; 
        color: white;
        padding: 20px;
        box-shadow: 0 0 10px #9df;
        z-index: 4;
    }

    .box-cover{
        width: 4px;
        height: 30px;
        position: absolute;
        top: -320px;
        left: 500px;
        background-color: #000;  
        padding: 20px;
        z-index: 3;
    }


    .triangle-container {
      position: relative;
      width: 0;
      height: 0;
      z-index: 5;
    }

    .gradient-triangle {
      width: 200px;
      height: 170px;
      background: linear-gradient(45deg, #9df, white);
      clip-path: polygon(50% 100%, 0% 0%, 100% 0%);
      position: absolute;
      top: -88px;
      left: -100px;
      z-index: 5;
      animation: pulse 5s infinite ease-in-out;
      opacity: 1;
      filter: drop-shadow(0 0 20px #9df);
    }

    .triangle-text {
      position: absolute;
      top: -50px;
      left: -46px;
      color: black;
      font-size: 24px;
      z-index: 5;
      animation: pulse 5s infinite ease-in-out;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.02);
        opacity: 0.95;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .hidden{
      display: none;
    }

    .circle {
      position: absolute;
      width: 410px;
      height: 410px;
      border: 2px solid #9df;
      border-radius: 50%;
      top: -230px;
      left: -210px;
      z-index: 1;
      box-shadow: 0 0 20px #9df;
      overflow: hidden;
      transition: box-shadow 0.3s ease-in-out, border-color 0.3s ease-in-out;
      cursor: pointer;
    }

    .circle:hover {
      box-shadow: 0 0 30px #9df, 0 0 60px rgba(153, 221, 255, 0.7);
      border-color: white;
    }

    .circle-highlight {
      box-shadow: 0 0 30px #9df, 0 0 60px rgba(153, 221, 255, 0.7);
      border-color: white;
    }

    .circle.active {
      position: relative;
      border-color: #fff;
      box-shadow: 0 0 40px #9df, 0 0 80px rgba(153, 221, 255, 0.8);
    }

    /* New styles for audio bars */
    .audio-bars-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: flex-end;
      height: 80%;
      width: 80%;
      justify-content: space-between;
    }

    .audio-bar {
      width: 4px; /* Adjust bar width as needed */
      background-color: #9df;
      margin: 0 2px;
      border-radius: 2px;
      opacity: 0.8;
      animation: bar-pulse 1s infinite alternate;
    }

    @keyframes bar-pulse {
      0% { transform: scaleY(0.2); }
      50% { transform: scaleY(1); }
      100% { transform: scaleY(0.4); }
    }

    /* Ensure only active state has the animation */
    .circle:not(.active) .audio-bar {
      animation: none;
      height: 0;
    }

    .circle-below {
      position: absolute;
      width: 220px;
      height: 220px;
      background-color: transparent;  /*rgba(153, 221, 255, 0.4)*/
      border-radius: 50%;
      border: 8px solid #9df;
      top: 54px;
      left: 507px;
      z-index: 1;
      box-shadow: 0 0 20px #9df, 0 0 40px rgba(153, 221, 255, 0.4);
      cursor: pointer;
      transition: box-shadow 0.3s ease;
    }

    .circle-below:hover {
      box-shadow: 0 0 30px #9df, 0 0 60px rgba(153, 221, 255, 0.6);
    }

    .popup-box {
      position: absolute;
      width: 300px;
      height: 250px;
      background-color: rgba(0, 0, 0, 0.9);
      border: 2px solid #9df;
      border-radius: 10px;
      top: 110px;
      left: 420px;
      z-index: 10;
      padding: 20px;
      color: #9df;
      box-shadow: 0 0 20px #9df;
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
      transform-origin: center center;
    }

    .popup-box.visible {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: all;
    }

    .popup-box::before {
      content: '';
      position: absolute;
      top: 50%;
      right: -10px;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-left: 10px solid #9df;
    }

    .popup-box h3 {
      margin: 0 0 15px 0;
      text-align: center;
      font-size: 20px;
      color: #9df;
      text-shadow: 0 0 10px #9df;
    }

    .popup-box h4 {
      margin: 15px 0 10px 0;
      color: #9df;
      text-shadow: 0 0 5px #9df;
    }

    .popup-box p {
      margin: 5px 0;
      font-family: monospace;
      font-size: 14px;
    }

    .custom-image {
      position: absolute;
      width: 200px;
      height: 200px;
      top: 0px;
      left: 520px;
      object-fit: contain;
      filter: drop-shadow(0 0 10px #9df);
      transition: all 0.3s ease;
      z-index: 0;
    }

    .graph-panel {
      position: absolute;
      bottom: -465px;
      right: -840px;
      width: 160px;
      height: 60px;
      background-color: #bbb7b7; 
      border: 6px solid #9df;
      box-shadow: 0 0 15px rgba(153, 221, 255, 0.3);
      z-index: 6;
    }

    .online-text {
      position: absolute;
      bottom: -445px;
      right: -805px;
      font-family: 'Orbitron', sans-serif;
      font-size: 24px;
      font-weight: bold;
      color: Lime;
      text-transform: uppercase;
      z-index: 7;
    }


    .left-panel-shape {
      position: absolute;
      top: -300px;
      left: -860px;
      width: 180px;
      height: 69.999vh;
      background: rgba(218, 223, 225, 0.4);
      clip-path: polygon(
        0% 0%, 
        80% 0%, 
        100% 10%, 
        100% 40%,
        70% 60%, 
        100% 80%, 
        100% 100%, 
        0% 100%
      );
      z-index: 5;
    }

  .bottom-panel-box {
      position: absolute;
      bottom: -485px;
      left: -855px;
      width: 100vw;
      height: 133.6px;
      background: rgba(218, 223, 225, 0.4);
      clip-path: polygon(
        0% 0%,
        15% 0%,
        18% 20%,
        82% 20%, 
        85% 0%,
        100% 0%,
        100% 100%,
        0% 100%
      );
      z-index: 5;
    }

    /* Webcam Styles */
    .webcam-container {
      position: absolute;
      top: -400px;
      right: -530px;
      width: 1020px;
      height: 740px;
      background-color: rgba(0, 0, 0, 0.9);
      border: 2px solid #9df;
      border-radius: 10px;
      padding: 10px;
      z-index: 10;
      box-shadow: 0 0 20px #9df;
    }

    .webcam-video {
      width: 100%;
      height: 580px;
      object-fit: cover;
      border-radius: 5px;
      margin-bottom: 10px;
    }

    .webcam-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .webcam-button {
      padding: 8px 12px;
      background-color: #9df;
      color: #000;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s ease;
    }

    .webcam-button:hover {
      background-color: #fff;
      box-shadow: 0 0 10px #9df;
    }

    .webcam-button.active {
      background-color: #f44336;
      color: white;
    }

    .query-input-container {
      margin: 10px 0;
      display: flex;
      gap: 5px;
    }

    .custom-query-input {
      flex: 1;
      padding: 8px;
      border: 2px solid #9df;
      border-radius: 5px;
      background-color: rgba(0, 0, 0, 0.8);
      color: #9df;
      font-size: 12px;
    }

    .custom-query-input:focus {
      outline: none;
      border-color: #fff;
      box-shadow: 0 0 10px #9df;
    }

    .webcam-status {
      text-align: center;
      color: #9df;
      font-size: 12px;
      margin-top: 10px;
      font-family: monospace;
    }

    .webcam-button.small {
      padding: 6px 8px;
      font-size: 10px;
    }

    .stark-shape {
      position: absolute;
      top: -400px;
      left: -800px;
      width: 200px;
      height: 60px;
      background: linear-gradient(to right, #cfd8dc, #90a4ae);
      box-shadow: 0 0 15px rgba(153, 221, 255, 0.4);
      clip-path: polygon(0% 0%, 90% 0%, 100% 50%, 90% 100%, 0% 100%);
      z-index: 1;
    }

    .stark-text {
      position: absolute;
      top: -382px;
      left: -758px;
      font-family: 'Orbitron', sans-serif;
      font-size: 24px;
      font-weight: bold;
      color: #9df;
      text-transform: uppercase;
      transform: skewX(-15deg);
      z-index: 5;
    }

    .idk-box {
      position: absolute;
      top: -385.5px;
      left: -820px;
      width: 200px;
      height: 35px;
      background-color: black;
      z-index: 2;
    }

    
    .jarvis-v{
      position: absolute;
      top: -270px;
      left: -820px;
      font-family: 'Orbitron', sans-serif;
      font-size: 24px;
      font-weight: bold;
      color: #9df;
      text-transform: uppercase;
      z-index: 6;
    }

    .jarvis-vv{
      position: absolute;
      top: -235px;
      left: -810px;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      font-weight: bold;
      color: #9df;
      text-transform: uppercase;
      z-index: 6;
    }

    .ports{
      position: absolute;
      top: -108px;
      left: -845px;
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      font-weight: bold;
      color: rgb(125, 125, 125);
      text-shadow: 0 0 20px black;
      text-transform: uppercase;
      z-index: 8;
    }

    .ollama{
      position: absolute;
      top: -80px;
      left: -845px;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: bold;
      color: rgb(125, 125, 125);
      text-transform: uppercase;
      z-index: 8;
    }

    .web-ui{
      position: absolute;
      top: -65px;
      left: -845px;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: bold;
      color: rgb(125, 125, 125);
      text-transform: uppercase;
      z-index: 8;
    }

    .ios{
      position: absolute;
      top: -50px;
      left: -845px;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: bold;
      color: rgb(125, 125, 125);
      text-transform: uppercase;
      z-index: 8;
    }

    .MEDIA{
      position: absolute;
      top: -20px;
      left: -845px;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: bold;
      color: rgb(125, 125, 125);
      text-transform: uppercase;
      z-index: 8;
    }

    .JSCAD{
      position: absolute;
      top: -35px;
      left: -845px;
      font-family: 'Orbitron', sans-serif;
      font-size: 12px;
      font-weight: bold;
      color: rgb(125, 125, 125);
      text-transform: uppercase;
      z-index: 8;
    }

    .line {
      position: absolute;
      width: 200px;
      height: 3px;
      background-color: #9df;
      box-shadow: 0 0 32px #9df, 0 0 24px #9df;
    }

    .line-long {
      position: absolute;
      width: 300px;
      height: 2px;
      background-color: #9df;
      box-shadow: 0 0 32px #9df, 0 0 24px #9df;
    }

    .line-short {
      position: absolute;
      width: 120px;
      height: 3px;
      background-color: #9df;
      box-shadow: 0 0 32px #9df, 0 0 24px #9df;
    }

    .storage-box {
      position: absolute;
      bottom: -475px;
      left: -830px;
      width: 200px;
      height: 70px;
      background-color: rgb(102, 100, 100);
      border: 6px solid black;
      z-index: 8;
    }

    .storage-full {
      position: absolute;
      bottom: -469px;
      left: -824px;
      width: 100px;
      height: 70px;
      background-color: #9df;
      z-index: 9;
    }

    .storage-text {
      position: absolute;
      bottom: -390px;
      left: -830px;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      font-weight: bold;
      color: #9df;
      text-transform: uppercase;
    }

    .storage-box-text {
      position: absolute;
      bottom: -447px;
      left: -805px;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      font-weight: bold;
      color: rgb(0, 0, 0);
      text-transform: uppercase;
      z-index: 10;
    }


    .weather-temp {
      position: absolute;
      top: -320px;
      left: 350px;
      font-family: 'Orbitron', sans-serif;
      font-size: 60px;
      font-weight: bold;
      color: #9df;
      text-shadow: 0 0 10px #9df;
      text-transform: uppercase;
      z-index: 5;
    }


    .clock {
      position: absolute;
      top: -400px;
      left: 320px;
      color: #9df;
      font-size: 24px;
      font-family: monospace;
      font-weight: bold;
      z-index: 5;
      text-shadow: 0 0 10px #9df;
      width: 200px;
      text-align: center;
    }

    .clock-small {
      position: absolute;
      top: -87px;
      left: 330px;
      color: #797979;
      font-size: 10px;
      font-family: monospace;
      z-index: 10;
      width: 160px;
      text-align: center;
      text-shadow: 0 0 5px #363636;
    }

    .JV {
      position: absolute;
      top: 143px;
      left: -360px;
      color: #797979;
      font-size: 10px;
      font-family: monospace;
      z-index: 10;
      width: 150px;
      text-align: center;
      text-shadow: 0 0 5px #363636;
    }

    .V {
      position: absolute;
      top: 124px;
      left: -360px;
      color: #797979;
      font-size: 10px;
      font-family: monospace;
      z-index: 10;
      width: 150px;
      text-align: center;
      text-shadow: 0 0 5px #363636;
    }

    .J {
      position: absolute;
      top: -215px;
      left: -350px;
      color: #797979;
      font-size: 10px;
      font-family: monospace;
      z-index: 10;
      width: 150px;
      text-align: center;
      text-shadow: 0 0 5px #363636;
    }


    .status {
      position: absolute;
      top: 405px;
      left: 560px;
      color: #000000;
      font-size: 20px;
      font-family: monospace;
      z-index: 10;
      width: 100px;
      text-align: center;
      text-shadow: 0 0 5px #363636;
    }
  

    .clock::before {
      content: attr(data-time);
    }

    .clock-small::before {
      content: attr(data-time);
    }

    @keyframes ripple {
      0% {
        transform: scale(0.6);
        opacity: 0.9;
      }
      50% {
        transform: scale(0.6);
        opacity: 0.5;
      }
      100% {
        transform: scale(0.6);
        opacity: 0.9;
      }
    }

    #elevenlabs-widget-container {
      position: absolute;
      top: 100px;
      left: 0px;
      z-index: 100; /* Ensure it's above other elements */
    }

  </style>
</head>
<body>
  <div class="wrapper">
    <!-- Tired of formatting everyting is going here-->
    <div class="left-panel-shape"></div>
    <div class="bottom-panel-box"></div>
    <div class="stark-shape"></div>
    <div class="stark-text">ADD YOUR NAME</div>
    <div class="idk-box"></div>
    <div class="graph-panel"></div>
    <div class="online-text">‚Ä¢ ONLINE</div>
    <div class="storage-box"></div>
    <div class="storage-full"></div>
    <div class="storage-text">STORAGE USED : 52%</div>
    <div class="storage-box-text">127GB&nbsp;&nbsp;&nbsp;245GB</div>
    <div id="weather-temp" class="weather-temp">Loading...</div>
    <div class="jarvis-v">JARVIS</div>
    <div class="jarvis-vv">V 0.2.7</div>
    <div class="JV">V 0.2.7</div>
    <div class="V">JARVIS</div>
    <div class="J">‚Ä¢ ONLINE</div>
    <div class="status">SYSTEM STATUS :</div>
    <div class="ports">PORTS OPEN</div>
    <div class="ollama">ADD PORT NAME</div>
    <div class="web-ui">ADD PORT NAME</div>
    <div class="ios">ADD PORT NAME</div>
    <div class="JSCAD">JADD PORT NAME</div>
    <div class="MEDIA">ADD PORT NAME</div>
    <!--circut lines-->
    <div id="left-lines">
      <div class="line" style="top: -200px; left: -311px;"></div> <!--initially 100, 50, use for conversion of other lines-->
      <div class="line-long" style="top: -107px; left: -492px;"></div>
      <div class="line-short" style="top: -55px; left: -327px;"></div>
      <div class="line" style="top: 22px; left: -404px;"></div>
      <div class="line" style="top: 137px; left: -331px;"></div>
    </div>
    <div id="right-lines">
      <div class="line" style="top: -159px; left: 153px;"></div>
      <div class="line-long" style="top: -70px; left: 198px;"></div>
      <div class="line" style="top: 33px; left: 194px;"></div>
      <div class="line-short" style="top: 100px; left: 161px;"></div>
    </div>


    

    <!-- Arc Reactor SVG in bottom right corner -->
    <div style="position: fixed; bottom: 153px; right: 70px; width: 320px; height: 320px; z-index: 5; pointer-events: none;">
      <svg viewBox="0 0 300 300" width="100%" height="100%">
        <!-- Center glow -->
        <circle cx="150" cy="150" r="40" fill="white" stroke="#000" stroke-width="6" filter="url(#glow)" />
        <!-- Ring segments -->
        <g transform="translate(150,150)">
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(0)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(40)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(80)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(120)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(160)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(200)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(240)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(280)" />
          <path d="M -20 -90 Q 0 -100 20 -90 L 15 -70 Q 0 -75 -15 -70 Z" fill="white" stroke="#003366" stroke-width="3" filter="url(#glow)" transform="rotate(320)" />
        </g>
        <!-- Glow filter -->
        <defs>
          <filter id="glow">
            <feGaussianBlur stdDeviation="4" result="blur" />
            <feMerge>
              <feMergeNode in="blur" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
      </svg>
    </div>

    <!-- Circle -->
    <div class="circle"></div>
    
    <!-- World Map Image -->
    <svg class="world-map" viewBox="0 0 2000 1001" xmlns="http://www.w3.org/2000/svg">
      <image href="https://simplemaps.com/static/demos/resources/svg-library/svgs/world.svg"
             width="2000" height="1001" />
    </svg>
    <div class="circle-below">
      <script>
        // Create 48 spikes (one every 7.5 degrees) with random variations
        for (let i = 0; i < 48; i++) {
          const spike = document.createElement('div');
          spike.className = 'spike';
          const rotation = i * 7.5;
          spike.style.setProperty('--rotation', `${rotation}deg`);
          // Add random delay and duration for more irregular movement
          const delay = Math.random() * 2;
          const duration = 2 + Math.random();
          spike.style.animation = `pulse-spike ${duration}s infinite ${delay}s`;
        }
      </script>
    </div>
    <div class="popup-box">
      <h3>Weather Forecast</h3>
      <div id="hourly-forecast"></div>
      <div id="daily-forecast"></div>
    </div>
    <div class="box"></div> 
    <div class="box-cover"></div>

    <!-- Existing Lines -->
    <div class="green-line" style="top: -122px; left: -170px; transform: rotate(34deg);"></div>
    <div class="green-line" style="top: -122px; left: 108px; transform: rotate(-34deg);"></div>
    <div class="green-line" style="top: 120px; left: -31.5px; transform: rotate(90deg);"></div>

    <!-- Main Triangle Layers -->
    <div class="triangle"></div>
    <div class="triangle-smaller"></div>

    <!-- Inner Triangle Layers-->
<div class="triangle-container">
    <div class="gradient-triangle"></div>
    <div class="triangle-text"><strong>JARVIS</strong></div>
</div>
<div class="clock" data-time=""></div>
<div class="clock-small" data-time=""></div>

<script>
  window.onload = () => {
    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
  };
</script>
</body>


<script>
  // Check if speech recognition is available
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    console.error('Speech recognition not supported in this browser');
  } else {
    console.log('Speech recognition is supported');
  }

  const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  recognition.lang = "en-US";
  recognition.interimResults = false;

  const speak = (text) => {
    console.log('Attempting to speak:', text);
    fetch("https://api.elevenlabs.io/v1/text-to-speech/*ADD VOICE ID HERE*", {
      method: "POST",
      headers: {
        "xi-api-key": "*ADD API HERE*",
        "Content-Type": "application/json",
        "Accept": "audio/mpeg"
      },
      body: JSON.stringify({
        text: text,
        voice_settings: {
          stability: 0.9,
          similarity_boost: 0.75
        }
      })
    })
    .then(res => {
      console.log('TTS API response:', res);
      return res.blob();
    })
    .then(blob => {
      const audio = new Audio(URL.createObjectURL(blob));
      console.log('Playing audio...');
      audio.play();
      audio.onended = () => {
        if (isVoiceAgentActive) {
          recognition.start(); // Only restart loop if agent is still active
        }
      };
    });
  };

  recognition.onresult = (event) => {
    const userInput = event.results[0][0].transcript;

    // If we have a pending image (from space bar), send it with the spoken query
    if (pendingImageBlob && pendingImageBase64) {
      // Create FormData for file upload
      const formData = new FormData();
      formData.append('query', userInput);
      formData.append('image', pendingImageBlob, 'webcam-capture.jpg');
      formData.append('imageBase64', pendingImageBase64);
      formData.append('timestamp', Date.now().toString());

      fetch("https://atimmeny.app.n8n.cloud/webhook/n8n", {
        method: "POST",
        body: formData
      })
      .then(res => res.json())
      .then(data => {
        console.log('Frame+voice analysis:', data);
        updateStatus('Analysis complete');
        // Handle array response from n8n - access first element then output property
        const text = (data[0] && data[0].output) || data.output || data.voice_output;
        console.log('Final text to speak (image+voice):', text);
        if (text && isWebcamOpen) {
          console.log('Calling speak() with:', text);
          speak(text);
        } else {
          console.log('Not calling speak():', { text, isWebcamOpen });
        }
      })
      .catch(err => {
        console.error('Error sending frame+voice:', err);
        updateStatus('Error sending image+voice');
      });
      // Clear pending image after sending
      pendingImageBlob = null;
      pendingImageBase64 = null;
      return;
    }

    const auth = btoa("admin:canes27");

  fetch("https://atimmeny.app.n8n.cloud/webhook/n8n", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Basic ${auth}`
    },
    body: JSON.stringify({ query: userInput })
  })
    .then(res => res.json())
    .then(data => {
      // Debug: Log the actual response structure
      console.log('n8n response data:', data);
      console.log('data type:', typeof data);
      console.log('data.output:', data.output);
      console.log('data.voice_output:', data.voice_output);
      
      // Handle array response from n8n - access first element then output property
      const text = (data[0] && data[0].output) || data.output || data.voice_output || "Sorry, I didn't understand that.";
      console.log('Final text to speak:', text);
      speak(text);
    })
    .catch(err => {
      console.error(err);
    });
  };

  recognition.onend = () => {
    // Optional: Restart listening automatically on silence
    // recognition.start(); ‚Üê use this if you want always-on listening
  };
</script>
<script>
  const circle = document.querySelector('.circle');
  const circleBelow = document.querySelector('.circle-below');
  const elementsToHighlight = document.querySelectorAll('.triangle, .triangle-smaller, .gradient-triangle, .box');
  const clock = document.querySelector('.clock');
  const clockSmall = document.querySelector('.clock-small');
  const popupBox = document.querySelector('.popup-box');
  const lastUpdate = document.getElementById('last-update');

  // Get elements to hide/show
  const elementsToHide = document.querySelectorAll('.triangle, .triangle-smaller, .triangle-container, .green-line');
  const elevenlabsWidgetContainer = document.getElementById('elevenlabs-widget-container'); // Get ElevenLabs widget container

  // Add voice agent state
  let isVoiceAgentActive = false;

  // Add click handler for voice agent activation
  circle.addEventListener('click', () => {
    console.log('Circle clicked');
    isVoiceAgentActive = !isVoiceAgentActive;
    console.log('Voice agent active:', isVoiceAgentActive);

    if (isVoiceAgentActive) {
      console.log('Attempting to start voice agent');
      circle.classList.add('active');

      // Add audio bars container
      const barsContainer = document.createElement('div');
      barsContainer.className = 'audio-bars-container';
      circle.appendChild(barsContainer);

      // Add multiple audio bars
      const numberOfBars = 40;
      for (let i = 0; i < numberOfBars; i++) {
        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        bar.style.animationDelay = `${Math.random() * 0.5}s`;
        bar.style.height = `${(Math.random() * 80) + 20}%`;
        barsContainer.appendChild(bar);
      }

      // Hide triangles and lines
      elementsToHide.forEach(el => el.classList.add('hidden'));

      // (Optional) Hide widget container if it's unused or empty
      if (elevenlabsWidgetContainer) elevenlabsWidgetContainer.classList.remove('hidden');

      console.log('Starting speech recognition');
      try {
        recognition.start();
        console.log('Speech recognition started successfully');
      } catch (error) {
        console.error('Failed to start speech recognition:', error);
      }

    } else {
      circle.classList.remove('active');

      // Remove audio bars container and its children
      const barsContainer = circle.querySelector('.audio-bars-container');
      if (barsContainer) barsContainer.remove();

      // Show triangles and lines
      elementsToHide.forEach(el => el.classList.remove('hidden'));

      // Hide widget container (optional)
      if (elevenlabsWidgetContainer) elevenlabsWidgetContainer.classList.add('hidden');

      console.log('Voice agent deactivated');

      // STOP JARVIS LOOP
      recognition.abort();
    }
  });

  // Preserve existing hover functionality
  elementsToHighlight.forEach(element => {
    element.addEventListener('mouseenter', () => {
      if (!isVoiceAgentActive) {
        circle.classList.add('circle-highlight');
      }
    });
    element.addEventListener('mouseleave', () => {
      if (!isVoiceAgentActive) {
        circle.classList.remove('circle-highlight');
      }
    });
  });

  function updateClock() {
    const now = new Date();
    const dateString = now.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
    const timeString = now.toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit', 
      second: '2-digit', 
      hour12: true 
    });
    const fullString = `${dateString} ${timeString}`;
    
    // Update both clocks directly
    clock.textContent = fullString;
    clockSmall.textContent = fullString;
    
    if (lastUpdate) {
      lastUpdate.textContent = timeString;
    }
  }

  // Update clock immediately and then every second
  updateClock();
  setInterval(updateClock, 1000);

  if (circleBelow) {
    circleBelow.addEventListener('click', async () => {
      popupBox.classList.toggle('visible');
      if (popupBox.classList.contains('visible')) {
        await fetchForecast();
      }
    });
  }

  // Close popup when clicking outside
  document.addEventListener('click', (e) => {
    if (popupBox && !popupBox.contains(e.target) && !circleBelow.contains(e.target)) {
      popupBox.classList.remove('visible');
    }
  });

  // Circuit animation
  const circuitLines = document.querySelectorAll('.circuit-line');
  const circuitNodes = document.querySelectorAll('.circuit-node');

  function animateCircuit() {
    circuitLines.forEach((line, index) => {
      const delay = index * 0.2;
      line.style.animation = `circuitPulse 2s infinite ${delay}s`;
    });

    circuitNodes.forEach((node, index) => {
      const delay = index * 0.2;
      node.style.animation = `circuitPulse 2s infinite ${delay}s`;
    });
  }

  animateCircuit();

  async function fetchWeather() {
  const apiKey = "*ADD API HERE*";
  const city = "Raleigh"; 
  const url = `https://api.openweathermap.org/data/2.5/weather?q=${city}&units=imperial&appid=${apiKey}`;

  try {
    const response = await fetch(url);
    const data = await response.json();
    const temp = Math.round(data.main.temp);
    document.getElementById("weather-temp").textContent = `${temp}¬∞F`;
  } catch (error) {
    document.getElementById("weather-temp").textContent = "Weather Error";
  }
}

fetchWeather();
setInterval(fetchWeather, 10 * 60 * 1000); 

async function fetchForecast() {
  const apiKey = "*ADD API HERE*";
  const city = "Raleigh";
  const url = `https://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${apiKey}&units=imperial`;

  try {
    const response = await fetch(url);
    const data = await response.json();
    const list = data.list;
    const now = new Date();
    
    // COME BACK AND FIX THIS IT SUCKS AND DOESNT WORK
    const hourly = list.filter(item => {
      const itemDate = new Date(item.dt_txt);
      return itemDate > now;
    }).slice(0, 5);

    const daily = list.filter(item => {
      const itemDate = new Date(item.dt_txt);
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const dayAfter = new Date(now);
      dayAfter.setDate(dayAfter.getDate() + 2);
      
      return itemDate.getDate() === tomorrow.getDate() || itemDate.getDate() === dayAfter.getDate();
    }).slice(0, 2);

    const hourlyDiv = document.getElementById("hourly-forecast");
    const dailyDiv = document.getElementById("daily-forecast");

    if (hourly.length > 0) {
      hourlyDiv.innerHTML = "<h4>Next 15 Hours</h4>" + hourly.map(item => {
        const date = new Date(item.dt_txt);
        const time = date.toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit', 
          hour12: true,
          timeZone: 'America/New_York'
        });
        return `<p>${time} - ${Math.round(item.main.temp)}¬∞F, ${item.weather[0].description}</p>`;
      }).join("");
    } else {
      hourlyDiv.innerHTML = "<h4>Next 15 Hours</h4><p>No hourly data available</p>";
    }

    if (daily.length > 0) {
      dailyDiv.innerHTML = "<h4>Next 2 Days</h4>" + daily.map(item => {
        const date = new Date(item.dt_txt);
        const dayName = date.toLocaleDateString('en-US', { 
          weekday: 'short',
          timeZone: 'America/New_York'
        });
        return `<p>${dayName} - ${Math.round(item.main.temp)}¬∞F, ${item.weather[0].description}</p>`;
      }).join("");
    } else {
      dailyDiv.innerHTML = "<h4>Next 2 Days</h4><p>No daily data available</p>";
    }
  } catch (error) {
    const hourlyDiv = document.getElementById("hourly-forecast");
    const dailyDiv = document.getElementById("daily-forecast");
    hourlyDiv.innerHTML = "<h4>Next 15 Hours</h4><p>Error loading forecast</p>";
    dailyDiv.innerHTML = "<h4>Next 2 Days</h4><p>Error loading forecast</p>";
  }
}

// Webcam functionality
let webcamStream = null;
let webcamInterval = null;
let isWebcamActive = false;
let isWebcamOpen = false;
let webcamContainer, webcamVideo, webcamCanvas, webcamStatus, queryInputContainer, customQueryInput, sendCustomQuery;
let requestPermission, captureOnly, voiceOnly, typePrompt, captureAndType;

// Add variables to store captured image for space bar + voice
let pendingImageBlob = null;
let pendingImageBase64 = null;

// Initialize webcam elements after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  webcamContainer = document.getElementById('webcam-container');
  webcamVideo = document.getElementById('webcam-video');
  webcamCanvas = document.getElementById('webcam-canvas');
  webcamStatus = document.getElementById('webcam-status');
  queryInputContainer = document.getElementById('query-input-container');
  customQueryInput = document.getElementById('custom-query-input');
  sendCustomQuery = document.getElementById('send-custom-query');
  requestPermission = document.getElementById('request-permission');
  captureOnly = document.getElementById('capture-only');
  voiceOnly = document.getElementById('voice-only');
  typePrompt = document.getElementById('type-prompt');
  captureAndType = document.getElementById('capture-and-type');

  // Add event listeners only after elements are found
  if (requestPermission) {
    requestPermission.addEventListener('click', () => {
      if (!isWebcamActive) {
        startWebcam();
      } else {
        updateStatus('Webcam already active');
      }
    });
  }

  if (captureOnly) {
    captureOnly.addEventListener('click', () => {
      if (isWebcamActive) {
        captureAndSendFrame("What do you see in this image?");
      } else {
        updateStatus('Please request camera permission first');
      }
    });
  }

  if (voiceOnly) {
    voiceOnly.addEventListener('click', () => {
      if (isWebcamActive) {
        startVoiceRecognition();
      } else {
        updateStatus('Please request camera permission first');
      }
    });
  }

  if (typePrompt) {
    typePrompt.addEventListener('click', () => {
      if (isWebcamActive) {
        showQueryInput();
      } else {
        updateStatus('Please request camera permission first');
      }
    });
  }

  if (captureAndType) {
    captureAndType.addEventListener('click', () => {
      if (isWebcamActive) {
        showQueryInput(true); // true = capture image after typing
      } else {
        updateStatus('Please request camera permission first');
      }
    });
  }

  if (sendCustomQuery) {
    sendCustomQuery.addEventListener('click', () => {
      const query = customQueryInput.value.trim();
      if (query) {
        hideQueryInput();
        captureAndSendFrame(query);
      }
    });
  }

  if (customQueryInput) {
    customQueryInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const query = customQueryInput.value.trim();
        if (query) {
          hideQueryInput();
          captureAndSendFrame(query);
        }
      }
    });
  }

  // Add keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Prevent shortcuts when typing in the custom query input
    if (
      document.activeElement === customQueryInput &&
      (e.key === 'w' || e.key === 'W' || e.key === 'b' || e.key === 'B' || e.key === ' ' || e.key === 'c' || e.key === 'C')
    ) {
      // Let the input handle the key normally
      return;
    }

    if (e.key === 'w' || e.key === 'W') {
      toggleWebcam();
    }
    
    // Space bar for capture + voice
    if (e.key === ' ') {
      e.preventDefault(); // Prevent page scroll
      if (isWebcamActive) {
        // Capture image and store it, then start voice recognition
        if (webcamVideo && webcamCanvas) {
          const canvas = webcamCanvas;
          canvas.width = webcamVideo.videoWidth;
          canvas.height = webcamVideo.videoHeight;
          const context = canvas.getContext('2d');
          context.drawImage(webcamVideo, 0, 0, canvas.width, canvas.height);
          canvas.toBlob((blob) => {
            if (blob) {
              pendingImageBlob = blob;
              // Convert blob to base64 for sending later
              const reader = new FileReader();
              reader.onload = function() {
                pendingImageBase64 = reader.result;
                // Start voice recognition after image is ready
                startVoiceRecognition();
                updateStatus('Voice recognition started - speak your question about the image');
              };
              reader.readAsDataURL(blob);
            }
          }, 'image/jpeg', 0.7);
        }
      } else {
        updateStatus('Please request camera permission first');
      }
    }

    // C key for capture only
    if (e.key === 'c' || e.key === 'C') {
      if (isWebcamActive) {
        captureAndSendFrame("What do you see in this image?");
      } else {
        updateStatus('Please request camera permission first');
      }
    }

    // V key for voice only
    if (e.key === 'v' || e.key === 'V') {
      if (isWebcamActive) {
        startVoiceRecognition();
      } else {
        updateStatus('Please request camera permission first');
      }
    }

    // N key for type prompt
    if (e.key === 'n' || e.key === 'N') {
      if (isWebcamActive) {
        showQueryInput();
      } else {
        updateStatus('Please request camera permission first');
      }
    }

    // B key for capture + type
    if (e.key === 'b' || e.key === 'B') {
      if (isWebcamActive) {
        showQueryInput(true);
      } else {
        updateStatus('Please request camera permission first');
      }
    }
  });
});

// Toggle webcam (W key)
async function toggleWebcam() {
  if (!isWebcamOpen) {
    webcamContainer.classList.remove('hidden');
    isWebcamOpen = true;
    await startWebcam();
    // Start speech recognition when webcam opens
    try {
      recognition.start();
    } catch (error) {
      console.error('Failed to start speech recognition:', error);
    }
  } else {
    webcamContainer.classList.add('hidden');
    isWebcamOpen = false;
    if (isWebcamActive) {
      stopWebcam();
    }
    hideQueryInput();
    updateStatus('Webcam interface closed');
    // Stop speech recognition when webcam closes
    recognition.abort();
  }
}

// Start webcam
async function startWebcam() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: 640 },
        height: { ideal: 480 }
      },
      audio: false
    });
    
    webcamStream = stream;
    webcamVideo.srcObject = stream;
    
    webcamVideo.onloadedmetadata = () => {
      webcamVideo.play();
      isWebcamActive = true;
      updateStatus('Webcam active - Use C / B keys or Space');
      
      // Remove automatic capture - only manual now
      // webcamInterval = setInterval(captureAndSendFrame, 2000);
    };
    
    console.log('Webcam started successfully');
  } catch (err) {
    console.error('Error accessing webcam:', err);
    updateStatus('Error: ' + err.message);
  }
}

// Stop webcam
function stopWebcam() {
  if (webcamStream) {
    webcamStream.getTracks().forEach(track => track.stop());
    webcamStream = null;
  }
  
  if (webcamInterval) {
    clearInterval(webcamInterval);
    webcamInterval = null;
  }
  
  webcamVideo.srcObject = null;
  isWebcamActive = false;
  updateStatus('Webcam stopped');
}

// Capture and send frame
function captureAndSendFrame(customQuery = "What do you see in this image?") {
  if (!webcamVideo || !webcamCanvas || !isWebcamActive) {
    updateStatus('Webcam not active');
    return;
  }

  updateStatus('Capturing image...');

  const canvas = webcamCanvas;
  canvas.width = webcamVideo.videoWidth;
  canvas.height = webcamVideo.videoHeight;

  const context = canvas.getContext('2d');
  context.drawImage(webcamVideo, 0, 0, canvas.width, canvas.height);

  // Convert to blob for better browser compatibility
  canvas.toBlob((blob) => {
    if (blob) {
      // Create blob URL for easy browser loading
      const blobUrl = URL.createObjectURL(blob);
      
      // Send to your n8n webhook
      sendFrameToN8N(blobUrl, blob, customQuery);
      
      // Clean up blob URL after a delay to prevent memory leaks
      setTimeout(() => {
        URL.revokeObjectURL(blobUrl);
      }, 5000); // Keep for 5 seconds then clean up
    }
  }, 'image/jpeg', 0.7);
}

// Send frame to n8n
function sendFrameToN8N(blobUrl, blob, customQuery) {
  // Create FormData for file upload
  const formData = new FormData();
  formData.append('query', customQuery);
  formData.append('image', blob, 'webcam-capture.jpg'); // JPEG file
  formData.append('imageUrl', blobUrl);
  formData.append('timestamp', Date.now().toString());

  // Convert blob to base64 and append to FormData
  const reader = new FileReader();
  reader.onload = function() {
    const base64Data = reader.result; // This is the data URL (e.g., data:image/jpeg;base64,...)
    formData.append('imageBase64', base64Data);

    // Send to your n8n webhook
    fetch("https://atimmeny.app.n8n.cloud/webhook/n8n", {
      method: "POST",
      body: formData
    })
    .then(res => res.json())
    .then(data => {
      console.log('Frame analysis:', data);
      updateStatus('Analysis complete');
      // Debug: Log output and webcam state
      // Handle array response from n8n - access first element then output property
      const text = (data[0] && data[0].output) || data.output || data.voice_output;
      console.log('Final text to speak (image analysis):', text);
      if (text && isWebcamOpen) {
        console.log('Calling speak() with:', text);
        speak(text);
      } else {
        console.log('Not calling speak():', { text, isWebcamOpen });
      }
    })
    .catch(err => {
      console.error('Error sending frame:', err);
      updateStatus('Error sending image');
    });
  };
  reader.readAsDataURL(blob); // This triggers the onload above
}

// Helper functions
function updateStatus(message) {
  if (webcamStatus) {
    webcamStatus.textContent = message;
  }
}

function showQueryInput(captureAfter = false) {
  if (queryInputContainer && customQueryInput) {
    queryInputContainer.classList.remove('hidden');
    customQueryInput.focus();
    if (captureAfter) {
      updateStatus('Type your question, then press Enter or click Send');
    } else {
      updateStatus('Type your question, then press Enter or click Send');
    }
  }
}

function hideQueryInput() {
  if (queryInputContainer) {
    queryInputContainer.classList.add('hidden');
    if (customQueryInput) {
      customQueryInput.value = '';
    }
  }
}

function startVoiceRecognition() {
  updateStatus('Voice recognition started - speak now');
  if (typeof recognition !== 'undefined' && recognition) {
    try {
      recognition.start();
    } catch (error) {
      updateStatus('Voice recognition error');
    }
  } else {
    updateStatus('Voice recognition not available');
  }
}

// Event listeners are now handled in the DOMContentLoaded section above
</script>

<!-- Webcam Container -->
<div id="webcam-container" class="webcam-container hidden">
  <video id="webcam-video" class="webcam-video" autoplay playsinline muted></video>
  <canvas id="webcam-canvas" style="display: none;"></canvas>
  
  <!-- Custom Query Input -->
  <div id="query-input-container" class="query-input-container hidden">
    <input id="custom-query-input" type="text" placeholder="Type your question about the image..." class="custom-query-input">
    <button id="send-custom-query" class="webcam-button">Send</button>
  </div>
  
  <!-- Control Buttons -->
  <div class="webcam-controls">
    <button id="capture-only" class="webcam-button">üì∏ C - Capture Only</button>
    <button id="capture-and-type" class="webcam-button">üìù B - Capture + Type</button>
  </div>
  
  <!-- Status Display -->
  <div id="webcam-status" class="webcam-status">Press W to open webcam</div>
</div>

</html>
